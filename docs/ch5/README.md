## 基础概念 

　　正则语法： let expression = /pattern/flags;

　　　　　　pattent: 正则规则

　　　　　　flags: 标志

　　
```js
// 匹配字符串中所有'ab'实例
let pattern1 = /ab/g;
 ```

　　1.1 标志（flags）：每个正则表达式可以带一个或多个标志，标明正则表达式的行为，正则表达式的匹配模式支持以下3个标志

　　　　g: 表示全局模式，匹配字符串所有的字符

　　　　i: 不区分大小写

　　　　m: 表示多行，在到达一行文本末尾时还会继续查找下一行是否存在与模式匹配的项

 
　　1.2　[] 方括号用于查找某个范围内的字符
　　

| 表达式 | 描述 |
| -- | -- |
| [abc] | 查找方括号之间的任何字符。 |
| [ ^abc ] | 查找任何不在方括号之间的字符。 |
| [0-9] | 查找任何从 0 至 9 的数字。 |
| [a-z] | 查找任何从小写 a 到小写 z 的字符。 |
| [A-Z] | 查找任何从大写 A 到大写 Z 的字符。 |
| [A-z] | 查找任何从大写 A 到小写 z 的字符。 |
| [adgk] | 查找给定集合内的任何字符。 |
| [ ^adgk ] | 查找给定集合外的任何字符。 |
| (red &#166; blue&#166;green) | 查找任何指定的选项。 |

　　	
	

　　1.3 正则表达式中使用的元字符必须转义--元字符在正在表达式中都有一种或多种特殊的用途,如果再匹配字符串中包含这些字符，必须转义。正则中的元字符串包括：

　　（） [] {} \ ^ $ | ? * + .
　　
```js
// 匹配第一个‘bat’或‘cat’,不区分大小写
let pattern2 = /[bc]at/i;

// 匹配所有已'at'结尾的3个字符串组合，不区分大小写
let pattern3 = /.at/gi;

//匹配第一个'[bc]at',不区分大小写
let pattern4 = /\[bc]at/i;

//匹配所有以'.at',不区分大小写
let pattern5 = /\.at/gi;
```

| 元字符 |描述 |
| -- | | -- |
| . | 查找单个字符，除了换行和行结束符。 |
|\w | 查找单词字符。|
|\W	| 查找非单词字符。|
|\d	|查找数字。|
|\D	|查找非数字字符。|
|\s	|查找空白字符。|
|\S	|查找非空白字符。|
|\b	|匹配单词边界。|
|\B	|匹配非单词边界。|
|\0	|查找 NUL 字符。|
|\n	|查找换行符。|
|\f	|查找换页符。|
|\r	|查找回车符。|
|\t	|查找制表符。
|\v	|查找垂直制表符。
|\xxx	|查找以八进制数 xxx 规定的字符。
|\xdd	|查找以十六进制数 dd 规定的字符。
|\uxxxx	|查找以十六进制数 xxxx 规定的 Unicode 字符。

***
###量词
|量词 |	描述|
| -- | | -- |
| n+ |	匹配任何包含至少一个 n 的字符串。
| n* |	匹配任何包含零个或多个 n 的字符串。
| n? |	匹配任何包含零个或一个 n 的字符串。
| n{X}|	匹配包含 X 个 n 的序列的字符串。
|n{X,Y}|	匹配包含 X 至 Y 个 n 的序列的字符串。
| n{X,}	|匹配包含至少 X 个 n 的序列的字符串。
| n$|	匹配任何结尾为 n 的字符串。
| ^n |	匹配任何开头为 n 的字符串。
| ?=n |	匹配任何其后紧接指定字符串 n 的字符串。
| ?!n |	匹配任何其后没有紧接指定字符串 n 的字符串。

****
###  所有正则表达式都有两种方式创建：

　　　　1.字面量形式来定义的正则表达式；
　　　　

　　　　2. 使用RegExp构造函数定义正则表达式

　　　　　　RegExp构造函数接收两个参数：参数1:  匹配的字符串模式， 参数2:  flags的字符串形式
　　　　　　
```js
// 匹配第一个‘bat’或‘cat’,不区分大小写

let pattern2 = /[bc]at/i;

// 与pattern2 相同，RegExp构造函数创建正则表达式
let re1 = new RegExp('[bc]at', 'i');
```
****
注意： 传递给构造函数的两个参数都是字符串,在某些情况下要对字符串进行双重转义。所有元字符都必须双重转义，那些转义过得字符也是如此，例如

　　　　　　　　\n (字符\在字符串中通常被转义为\\, 而在正则表达式字符串中就会变成\\\\)

　　　　      如下对比

| 字面量模式 |newRegExp等价的字符串    |            效果 |
| -- | | -- |
|/\[bc\]at/|'\\[bc\\]at'  |                    匹配 '[bc]at'

/\.at/   '\\.at' 匹配 '.at'

/name\/age/ 'name\\/age' 匹配 'name/age'

/\d.\d{1,2}/ '\\d.\\d{1,2}' 匹配'数字.数字（一个数字或两个数字）'　

/\w\\hello\\123/                  '\\w\\\\hello\\\\123'　       匹配 '单词\hello\123'

****
#### RegExp实例属性（flags）


|属性 |	描述 |
| -- | | -- |
|global	|RegExp 对象是否具有标志 g。	1	4
|ignoreCase|	RegExp 对象是否具有标志 i。	1	4
|lastIndex	|一个整数，标示开始下一次匹配的字符位置,从0算起。	1	4
|multiline	|RegExp 对象是否具有标志 m。	1	4
|source	 |正则表达式的源文本。
### 模块功能主要由两个命令构成：export和import

export命令用于规定模块的对外接口，

import命令用于输入其他模块提供的功能。

***
### export输出
一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。

```js
export const a = 'Jeson'
export let b = 'Jack'
export var c = 'Tom'
```
export命令对外部输出了三个变量。

export的写法，除了像上面这样，还有另外一种。
```js
const a = 'Jeson'
let b = 'Jack'
var c = 'Tom'

export { a, b, c }
```
与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。
***
export命令除了输出变量，还可以输出函数或类（class）。
```js
export function sum(x, y) {
    return x+y
}
```
通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。
```js
function a() {...}
function b() {...}

export {
    a as a1
    b as b1
    b as b2
}
```
通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。

***
需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。
```js
export 1 // 报错 1是一个值不是接口

var a = 2
export a // 报错 依旧是上一个问题
```
正确写法
```js
// 写法1
export var a = 1

// 写法2 
var b = 1
export { b }

// 写法3
var c = 1
export { c as d } // 输出d
```
function和class的输出，也必须遵守这样的写法

```js
// 报错
function a() {...}
export a

// 正确
export function b() {...}

// 正确
function c() {...}
export { c }
```
***
export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

```js
export var a = 1
setTimeout(() => a = 2, 500)
```
上面代码输出变量foo，值为bar，500毫秒之后变成baz。
这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《Module 的加载实现》一节。
***
export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。
```js
// 报错 SyntaxError
function name() {
    export default 'Jeson'
}
name()
```
***
### import命令
使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。

```js
// a.js
const a = 1
let b = 2
var c = 3
export { a, b, c }

// b.js
import { a, b, c } from './a'

function count() {
    return a+b+c
}
```
大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。
***
如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名
```js
import { a as a1 } from './a'
```
***
import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置
```js
import { myMethod } from 'util'
```
上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。

***
import命令具有提升效果，会提升到整个模块的头部，首先执行.本质是，import命令是编译阶段执行的，在代码运行之前
```js
a()
import { a } from 'my_module' 
```
***
由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构
```js
// 报错
import { 'f' + 'oo' } from 'my_module'

// 报错
const module = 'my_module'
import { foo } from module

// 报错
if (x===1) {
    import { a } from 'module1'
} else {
    import { b } from 'module2'
}
```
三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。
***
import语句会执行所加载的模块，因此可以有下面的写法。
```js
import 'count' // 仅执行count模块,不输入任何值
```
多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。

```js
import { a } from 'my_module'
import { b } from 'my_module'

// 等同于
import { a, b } from 'my_module'
```
虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。

